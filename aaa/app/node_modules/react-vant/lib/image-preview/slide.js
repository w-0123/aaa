"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Slide = void 0;
function _react() {
  const data = _interopRequireWildcard(require("react"));
  _react = function () {
    return data;
  };
  return data;
}
function _jsxRuntime() {
  const data = require("react/jsx-runtime");
  _jsxRuntime = function () {
    return data;
  };
  return data;
}
function _web() {
  const data = require("@react-spring/web");
  _web = function () {
    return data;
  };
  return data;
}
var _useDragAndPinch = require("../hooks/use-drag-and-pinch");
var _bound = require("../utils/bound");
var _rubberband = require("../utils/rubberband");
function _clsx() {
  const data = _interopRequireDefault(require("clsx"));
  _clsx = function () {
    return data;
  };
  return data;
}
var _utils = require("../utils");
var _LazyImage = require("../image/LazyImage");
var _lazyload = _interopRequireDefault(require("../lazyload"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
const [bem] = (0, _utils.createNamespace)('image-preview');
const Slide = props => {
  const {
    dragLockRef
  } = props;
  const controlRef = (0, _react().useRef)(null);
  const imgRef = (0, _react().useRef)(null);
  const [{
    zoom,
    x,
    y
  }, api] = (0, _web().useSpring)(() => ({
    zoom: 1,
    x: 0,
    y: 0,
    config: {
      tension: 200
    }
  }));
  const pinchLockRef = (0, _react().useRef)(false);
  function boundXY([x, y], rubberband) {
    const currentZoom = zoom.get();
    let xOffset = 0,
      yOffset = 0;
    if (imgRef.current && controlRef.current) {
      xOffset = ((currentZoom * imgRef.current.width || 0) - controlRef.current.clientWidth) / 2;
      yOffset = ((currentZoom * imgRef.current.height || 0) - controlRef.current.clientHeight) / 2;
    }
    xOffset = xOffset > 0 ? xOffset : 0;
    yOffset = yOffset > 0 ? yOffset : 0;
    const bounds = {
      left: -xOffset,
      right: xOffset,
      top: -yOffset,
      bottom: yOffset
    };
    if (rubberband) {
      return [(0, _rubberband.rubberbandIfOutOfBounds)(x, bounds.left, bounds.right, currentZoom * 50), (0, _rubberband.rubberbandIfOutOfBounds)(y, bounds.top, bounds.bottom, currentZoom * 50)];
    } else {
      return [(0, _bound.bound)(x, bounds.left, bounds.right), (0, _bound.bound)(y, bounds.top, bounds.bottom)];
    }
  }
  (0, _useDragAndPinch.useDragAndPinch)({
    onDrag: state => {
      if (state.tap && state.elapsedTime > 0 && state.elapsedTime < 1000) {
        // 判断点击时间>0是为了过滤掉非正常操作，例如用户长按选择图片之后的取消操作（也是一次点击）
        props.onTap();
        return;
      }
      const currentZoom = zoom.get();
      if (dragLockRef) {
        dragLockRef.current = currentZoom !== 1;
      }
      if (!pinchLockRef.current && currentZoom <= 1) {
        api.start({
          x: 0,
          y: 0
        });
      } else {
        if (state.last) {
          const [x, y] = boundXY([state.offset[0] + state.velocity[0] * state.direction[0] * 200, state.offset[1] + state.velocity[1] * state.direction[1] * 200], false);
          api.start({
            x,
            y
          });
        } else {
          const [x, y] = boundXY(state.offset, true);
          api.start({
            x,
            y,
            immediate: true
          });
        }
      }
    },
    onPinch: state => {
      var _a;
      pinchLockRef.current = !state.last;
      const [d] = state.offset;
      if (d < 0) return;
      const nextZoom = state.last ? (0, _bound.bound)(d, 1, props.maxZoom) : d;
      api.start({
        zoom: nextZoom,
        immediate: !state.last
      });
      (_a = props.onZoomChange) === null || _a === void 0 ? void 0 : _a.call(props, nextZoom);
      if (state.last && nextZoom <= 1) {
        api.start({
          x: 0,
          y: 0
        });
        if (dragLockRef) {
          dragLockRef.current = false;
        }
      } else {
        if (dragLockRef) {
          dragLockRef.current = true;
        }
      }
    }
  }, {
    target: controlRef,
    drag: {
      // filterTaps: true,
      from: () => [x.get(), y.get()],
      pointer: {
        touch: true
      }
    },
    pinch: {
      from: () => [zoom.get(), 0],
      pointer: {
        touch: true
      }
    }
  });
  const {
    lazyload
  } = props;
  const renderPlaceholder = () => {
    if (typeof lazyload === 'boolean') return (0, _LazyImage.getLazyImagePlaceholder)(bem);
    return lazyload.placeholder || (0, _LazyImage.getLazyImagePlaceholder)(bem);
  };
  return (0, _jsxRuntime().jsx)("div", Object.assign({
    className: (0, _clsx().default)(bem('slide')),
    onPointerMove: e => {
      if (zoom.get() !== 1) {
        e.stopPropagation();
      }
    }
  }, {
    children: (0, _jsxRuntime().jsx)("div", Object.assign({
      className: (0, _clsx().default)(bem('control')),
      ref: controlRef
    }, {
      children: (0, _jsxRuntime().jsx)(_web().animated.div, Object.assign({
        className: (0, _clsx().default)(bem('image-wrapper')),
        style: {
          translateX: x,
          translateY: y,
          scale: zoom
        }
      }, {
        children: props.lazyload ? (0, _jsxRuntime().jsx)(_lazyload.default, Object.assign({
          placeholder: renderPlaceholder()
        }, {
          children: (0, _jsxRuntime().jsx)("img", {
            ref: imgRef,
            src: props.image,
            draggable: false,
            alt: props.image
          })
        })) : (0, _jsxRuntime().jsx)("img", {
          ref: imgRef,
          src: props.image,
          draggable: false,
          alt: props.image
        })
      }))
    }))
  }));
};
exports.Slide = Slide;