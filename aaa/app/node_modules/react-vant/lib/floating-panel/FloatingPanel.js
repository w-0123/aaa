"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
function _react() {
  const data = _interopRequireWildcard(require("react"));
  _react = function () {
    return data;
  };
  return data;
}
function _jsxRuntime() {
  const data = require("react/jsx-runtime");
  _jsxRuntime = function () {
    return data;
  };
  return data;
}
function _clsx() {
  const data = _interopRequireDefault(require("clsx"));
  _clsx = function () {
    return data;
  };
  return data;
}
var _utils = require("../utils");
var _useEventListener = _interopRequireDefault(require("../hooks/use-event-listener"));
var _hooks = require("../hooks");
function _web() {
  const data = require("@react-spring/web");
  _web = function () {
    return data;
  };
  return data;
}
var _bound = require("../utils/bound");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
const [bem] = (0, _utils.createNamespace)('floating-panel');
/** Check if EL is scrolling reach its bottom */
function scrollReachBottom(el) {
  const scrollTop = (0, _utils.getScrollTop)(el);
  return scrollTop >= el.scrollHeight - (0, _utils.getVisibleHeight)(el);
}
const FloatingPanel = (0, _react().forwardRef)((props, ref) => {
  const {
    className,
    style,
    onHeightChange,
    anchors = [100]
  } = props;
  const sortAnchors = (0, _react().useMemo)(() => anchors.sort((a, b) => a - b), [anchors]);
  const [minAnchor, maxAnchor] = [sortAnchors[0], sortAnchors[Math.max(0, sortAnchors.length - 1)]];
  const root = (0, _react().useRef)();
  const header = (0, _react().useRef)();
  const body = (0, _react().useRef)();
  const dragging = (0, _react().useRef)(false);
  const draggingStartAt = (0, _react().useRef)(null);
  const touch = (0, _hooks.useTouch)();
  (0, _react().useImperativeHandle)(ref, () => ({
    moveTo: height => api.start({
      visibleH: height
    })
  }));
  const [{
    visibleH
  }, api] = (0, _web().useSpring)(() => ({
    visibleH: minAnchor,
    config: {
      tension: 300
    },
    onChange: () => onHeightChange === null || onHeightChange === void 0 ? void 0 : onHeightChange(visibleH.get())
  }), [minAnchor]);
  const onTouchStart = event => {
    touch.start(event);
    draggingStartAt.current = visibleH.get();
    dragging.current = true;
  };
  const onTouchMove = event => {
    const [headerEL, bodyEL] = [header.current, body.current];
    touch.move(event);
    if (visibleH.goal >= maxAnchor && bodyEL) {
      if (touch.firstMove.current && (
      // try going up to body top
      touch.deltaY.current > 0 && (0, _utils.getScrollTop)(bodyEL) > 0 ||
      // try going down to body bottom
      touch.deltaY.current < 0 && !scrollReachBottom(bodyEL))) {
        dragging.current = false;
      }
    }
    if (headerEL && headerEL.contains(event.target)) {
      dragging.current = true;
    }
    if (!dragging.current) return;
    (0, _utils.preventDefault)(event, true);
    api.start({
      visibleH: (0, _bound.bound)(draggingStartAt.current + -touch.deltaY.current, minAnchor, maxAnchor)
    });
  };
  const onTouchEnd = () => {
    const memoDraggingStartAt = draggingStartAt.current;
    dragging.current = false;
    draggingStartAt.current = null;
    touch.reset();
    if (memoDraggingStartAt) {
      const nearestAnchor = findNearestAnchor(sortAnchors, visibleH.get());
      api.start({
        visibleH: nearestAnchor,
        from: {
          visibleH: visibleH.get()
        }
      });
    }
  };
  (0, _useEventListener.default)('touchstart', onTouchStart, {
    target: root,
    passive: false
  });
  (0, _useEventListener.default)('touchmove', onTouchMove, {
    target: root,
    passive: false
  });
  (0, _useEventListener.default)('touchend', onTouchEnd, {
    target: root,
    passive: false
  });
  return (0, _jsxRuntime().jsxs)(_web().animated.div, Object.assign({
    ref: root,
    className: (0, _clsx().default)(bem(), className),
    style: Object.assign({
      height: maxAnchor,
      transform: visibleH.to(h => `translateY(calc(100% - ${h}px))`)
    }, style)
  }, {
    children: [(0, _jsxRuntime().jsx)("div", Object.assign({
      ref: header,
      className: (0, _clsx().default)(bem('header'))
    }, {
      children: (0, _jsxRuntime().jsx)("div", {
        className: (0, _clsx().default)(bem('thumb'))
      })
    })), (0, _jsxRuntime().jsx)(_web().animated.div, Object.assign({
      ref: body,
      className: (0, _clsx().default)(bem('body'))
    }, {
      children: props.children
    }))]
  }));
});
function findNearestAnchor(anchors, target) {
  return anchors.reduce((pre, cur) => {
    return Math.abs(target - pre) < Math.abs(target - cur) ? pre : cur;
  });
}
var _default = exports.default = FloatingPanel;