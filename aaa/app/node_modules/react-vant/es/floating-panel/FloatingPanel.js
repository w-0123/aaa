import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { forwardRef, useImperativeHandle, useMemo, useRef } from 'react';
import clsx from 'clsx';
import { createNamespace, getScrollTop, getVisibleHeight, preventDefault } from '../utils';
import useEventListener from '../hooks/use-event-listener';
import { useTouch } from '../hooks';
import { useSpring, animated } from '@react-spring/web';
import { bound } from '../utils/bound';
const [bem] = createNamespace('floating-panel');
/** Check if EL is scrolling reach its bottom */
function scrollReachBottom(el) {
  const scrollTop = getScrollTop(el);
  return scrollTop >= el.scrollHeight - getVisibleHeight(el);
}
const FloatingPanel = forwardRef((props, ref) => {
  const {
    className,
    style,
    onHeightChange,
    anchors = [100]
  } = props;
  const sortAnchors = useMemo(() => anchors.sort((a, b) => a - b), [anchors]);
  const [minAnchor, maxAnchor] = [sortAnchors[0], sortAnchors[Math.max(0, sortAnchors.length - 1)]];
  const root = useRef();
  const header = useRef();
  const body = useRef();
  const dragging = useRef(false);
  const draggingStartAt = useRef(null);
  const touch = useTouch();
  useImperativeHandle(ref, () => ({
    moveTo: height => api.start({
      visibleH: height
    })
  }));
  const [{
    visibleH
  }, api] = useSpring(() => ({
    visibleH: minAnchor,
    config: {
      tension: 300
    },
    onChange: () => onHeightChange === null || onHeightChange === void 0 ? void 0 : onHeightChange(visibleH.get())
  }), [minAnchor]);
  const onTouchStart = event => {
    touch.start(event);
    draggingStartAt.current = visibleH.get();
    dragging.current = true;
  };
  const onTouchMove = event => {
    const [headerEL, bodyEL] = [header.current, body.current];
    touch.move(event);
    if (visibleH.goal >= maxAnchor && bodyEL) {
      if (touch.firstMove.current && (
      // try going up to body top
      touch.deltaY.current > 0 && getScrollTop(bodyEL) > 0 ||
      // try going down to body bottom
      touch.deltaY.current < 0 && !scrollReachBottom(bodyEL))) {
        dragging.current = false;
      }
    }
    if (headerEL && headerEL.contains(event.target)) {
      dragging.current = true;
    }
    if (!dragging.current) return;
    preventDefault(event, true);
    api.start({
      visibleH: bound(draggingStartAt.current + -touch.deltaY.current, minAnchor, maxAnchor)
    });
  };
  const onTouchEnd = () => {
    const memoDraggingStartAt = draggingStartAt.current;
    dragging.current = false;
    draggingStartAt.current = null;
    touch.reset();
    if (memoDraggingStartAt) {
      const nearestAnchor = findNearestAnchor(sortAnchors, visibleH.get());
      api.start({
        visibleH: nearestAnchor,
        from: {
          visibleH: visibleH.get()
        }
      });
    }
  };
  useEventListener('touchstart', onTouchStart, {
    target: root,
    passive: false
  });
  useEventListener('touchmove', onTouchMove, {
    target: root,
    passive: false
  });
  useEventListener('touchend', onTouchEnd, {
    target: root,
    passive: false
  });
  return _jsxs(animated.div, Object.assign({
    ref: root,
    className: clsx(bem(), className),
    style: Object.assign({
      height: maxAnchor,
      transform: visibleH.to(h => `translateY(calc(100% - ${h}px))`)
    }, style)
  }, {
    children: [_jsx("div", Object.assign({
      ref: header,
      className: clsx(bem('header'))
    }, {
      children: _jsx("div", {
        className: clsx(bem('thumb'))
      })
    })), _jsx(animated.div, Object.assign({
      ref: body,
      className: clsx(bem('body'))
    }, {
      children: props.children
    }))]
  }));
});
function findNearestAnchor(anchors, target) {
  return anchors.reduce((pre, cur) => {
    return Math.abs(target - pre) < Math.abs(target - cur) ? pre : cur;
  });
}
export default FloatingPanel;